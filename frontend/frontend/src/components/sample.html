<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8" />
<title>Pink Pig Battle - Movesets (Piggy Breath)</title>
<style>
  :root { --bg:#fff; --ui:#111; --accent:#ef5da8; --gray:#e5e7eb; }
  html,body { height:100%; margin:0; background:var(--bg); font-family: Inter, system-ui, Arial; }
  .wrap {
    max-width: 960px;
    margin: 0 auto;
    padding: 0;
    display: flex;
    flex-direction: column;
    align-items: center;
    min-height: 100vh;
    justify-content: center;
  }
  canvas {
    display: block;
    margin: 0 auto 32px;
    image-rendering: pixelated;
    background: #fff8fc;
    border: none;
    border-radius: 32px;
    box-shadow: 0 8px 32px #e0b7ff44;
    z-index: 100;
    max-width: 100vw;
  }
  .hud {
    width: 100%;
    display: flex;
    justify-content: center;
    margin-bottom: 0;
    margin-top: 0;
    pointer-events: none;
  }
  .status {
    min-width: 260px;
    min-height: 38px;
    padding: 14px 28px;
    border-radius: 22px;
    background: rgba(255,255,255,0.7);
    box-shadow: 0 4px 24px #e0b7ff33;
    color: #222;
    font-size: 1.18rem;
    font-weight: 600;
    letter-spacing: 0.02em;
    text-align: center;
    border: none;
    backdrop-filter: blur(8px);
    pointer-events: auto;
  }
  .moves {
    display: flex;
    flex-direction: column;
    gap: 22px;
    position: fixed;
    right: 48px;
    top: 50%;
    transform: translateY(-50%);
    background: rgba(255,255,255,0.55);
    border-radius: 32px;
    box-shadow: 0 4px 24px #e0b7ff22;
    padding: 32px 18px;
    z-index: 10;
    align-items: stretch;
    max-width: 180px;
    width: 180px;
  }
  .moves button {
    border-radius: 18px;
    border: none;
    padding: 18px 0;
    font-size: 1.18rem;
    font-weight: 700;
    background: linear-gradient(90deg, #ffe0f0 0%, #e0f7fa 100%);
    color: var(--accent);
    box-shadow: 0 2px 8px #e0b7ff22;
    transition: transform 0.12s, box-shadow 0.12s, background 0.18s;
    margin: 0 0;
    letter-spacing: 0.04em;
    outline: none;
    border: 2.5px solid transparent;
  }
  .moves button.pink {
    background: linear-gradient(90deg, #ffe0f0 0%, #fbefff 100%);
    color: #ef5da8;
    border-color: #ef5da8;
  }
  .moves button:hover:not(:disabled) {
    background: linear-gradient(90deg, #e0f7fa 0%, #ffe0f0 100%);
    transform: scale(1.06) translateX(-4px);
    box-shadow: 0 4px 16px #ef5da855;
  }
  .moves button:disabled {
    opacity: .45;
    cursor: not-allowed;
    filter: grayscale(0.2);
  }
</style>
</head>
<body>
<h1 style="text-align:center;font-size:2.5rem;font-family:inherit;margin:32px 0 0 0;color:#ef5da8;letter-spacing:0.04em;">Pig Fight</h1>
<div class="wrap">
  <canvas id="c" width="960" height="460"></canvas>
  <div class="hud">
    <div class="status" id="status">Choose a move…</div>
  </div>
  <div class="moves" style="left:48px;right:auto;">
    <button id="btn-angel">Angel Dive</button>
    <button id="btn-welldone">Well Done</button>
    <button id="btn-heal">Self-Heal</button>
    <button id="btn-charge">Rampage</button>
  </div>
  <div class="moves">
    <button id="btn-dance" class="pink">Piggy Dance</button>
    <button id="btn-belly">Belly Row</button>
  <button id="btn-breath">Fart Attack</button>
    <button id="btn-slam">Body Slam</button>
  </div>
</div>

<script>
const canvas = document.getElementById('c');
const ctx = canvas.getContext('2d', { alpha:false });
ctx.imageSmoothingEnabled = false;

const statusEl  = document.getElementById('status');
const btnDance  = document.getElementById('btn-dance');
const btnBelly  = document.getElementById('btn-belly');
const btnBreath = document.getElementById('btn-breath');
const btnSlam   = document.getElementById('btn-slam');
const btnAngel    = document.getElementById('btn-angel');
const btnWellDone = document.getElementById('btn-welldone');
const btnHeal     = document.getElementById('btn-heal');
const btnCharge   = document.getElementById('btn-charge');

// ---- Asset ----
const pig = new Image();
pig.src = "pig1.png"; // your pig sprite

// ===================  LAYOUT (LEFT → RIGHT)  ===================
const SIZE = 150;                 // sprite size
const PLATE_Y = 330;              // both ovals share the same Y (center)
const LEFT_PLATE  = { x: 260, y: PLATE_Y };
const RIGHT_PLATE = { x: 740, y: PLATE_Y };

// Idle pig center (slightly above the plate)
const HOME = { x: LEFT_PLATE.x,  y: LEFT_PLATE.y - 30 };
const ENEMY_CENTER = { x: RIGHT_PLATE.x, y: RIGHT_PLATE.y - 30 };

const PLATFORM_W = 340, PLATFORM_H = 36; // oval size
const R = SIZE * 0.50;                   // ball radius (belly row)

// ---- State machine ----
let mode = "idle";                  // "idle" | "animating"
let currentMove = null;             // "dance" | "belly" | "breath" | "slam"
let moveStart = 0;
let moveDuration = 0;
// Flinch state for both pigs
let playerFlinch = 0;
let playerFlinchOffset = 0;
let opponentFlinch = 0;
let opponentFlinchOffset = 0;

function setStatus(text){ statusEl.textContent = text; }
function setMovesEnabled(enabled){
  [btnDance, btnBelly, btnBreath, btnSlam, btnAngel, btnWellDone, btnHeal, btnCharge].forEach(b => b.disabled = !enabled);
}
function playMove(name, durationMs){
  if (mode === "animating") return;
  mode = "animating"; currentMove = name; moveStart = performance.now();
  moveDuration = durationMs; setMovesEnabled(false);
  setStatus({
    dance : "Pig used Piggy Dance, its next attack deals double damage",
    belly : "Pig used Belly Row, dealing massive damage!",
    breath: "Pig used Fart Attack, dealing damage over time!",
    slam  : "Pig used Body Slam, dealing massive damage by taking some recoil!",
    angel : "Pig used Angel Dive, dealing insane damage!",
    welldone : "Pig cooks itself, hurting itself but gaining defense!",
    heal : "Pig heals some health!",
    charge : "Pig deals double damage, but takes a lot back!"
  }[name]);
  theta = 0; playerBreathParticles.length = 0; impactPuffs.length = 0;
}

// ---- Utilities ----
const clamp=(v,a,b)=>Math.max(a,Math.min(b,v));
const lerp=(a,b,t)=>a+(b-a)*t;
const easeInOut=t=>t<.5?2*t*t:1-Math.pow(-2*t+2,2)/2;
const easeOut=t=>1-(1-t)*(1-t);

// Plates & helpers
function drawPlates(){
  ctx.fillStyle = "#ffffff"; ctx.fillRect(0,0,canvas.width,canvas.height);

  // left plate (ally)
  ctx.save();
  ctx.fillStyle = "#e5e7eb";
  ctx.beginPath();
  ctx.ellipse(LEFT_PLATE.x, LEFT_PLATE.y, PLATFORM_W/2, PLATFORM_H/2, 0, 0, Math.PI*2);
  ctx.fill();
  ctx.restore();

  // right plate (opponent)
  ctx.save();
  ctx.fillStyle = "#f1f5f9";
  ctx.beginPath();
  ctx.ellipse(RIGHT_PLATE.x, RIGHT_PLATE.y, PLATFORM_W/2, PLATFORM_H/2, 0, 0, Math.PI*2);
  ctx.fill();
  ctx.restore();
}

function drawShadow(cx, w=32, h=10, alpha=0.16){
  ctx.save();
  ctx.globalAlpha = alpha;
  ctx.fillStyle = "#000";
  ctx.beginPath();
  ctx.ellipse(cx, PLATE_Y + 12, w, h, 0, 0, Math.PI*2);
  ctx.fill();
  ctx.restore();
}

function drawPigAt(x, y, {rot=0, sx=1, sy=1} = {}){
  ctx.save();
  ctx.translate(x, y);
  ctx.rotate(rot);
  ctx.scale(sx, sy);
  ctx.translate(-SIZE/2, -SIZE/2);
  ctx.drawImage(pig, 0,0,pig.width,pig.height, 0,0,SIZE,SIZE);
  ctx.restore();
}

function drawBallPig(cx, cy, {rot=0, sx=1, sy=1} = {}){
  ctx.save();
  ctx.translate(cx, cy);
  ctx.rotate(rot);
  ctx.scale(sx, sy);
  ctx.save();
  ctx.beginPath(); ctx.arc(0, 0, R*0.98, 0, Math.PI*2); ctx.clip();
  ctx.drawImage(pig, -SIZE/2, -SIZE/2, SIZE, SIZE);
  ctx.restore();
  ctx.restore();
}

// ---------- Idle & Dance ----------
function drawPigIdle(t){
  const squish = 1 + Math.sin(t*2)*0.02;
  let x = HOME.x + playerFlinchOffset;
  drawPigAt(x, HOME.y, { sy:squish });
  drawShadow(x, 34, 10, 0.14);
}
function drawPigDance(t, progress){
  const sway = Math.sin(t*4) * 0.22;
  const bounce = Math.max(0, Math.sin(t*8)) * 8;
  const scaleY = 1 + Math.sin(t*8) * 0.06;
  const edge = 0.3;
  let pulse = 1.0;
  if (progress < edge) pulse = 0.9 + 0.1*Math.sin((progress/edge)*Math.PI/2);
  else if (progress > 1-edge) pulse = 0.9 + 0.1*Math.sin(((1-progress)/edge)*Math.PI/2);
  const cx = HOME.x + playerFlinchOffset, cy = HOME.y - bounce - 4;
  drawPigAt(cx, cy, { rot: sway, sx:pulse, sy: scaleY*pulse });
  drawShadow(cx, 34 + Math.sin(t*8)*3, 10 - Math.sin(t*8)*1.2, 0.16);
}

// ---------------- BELLY ROW ----------------
let theta = 0;
function drawBellyRow(now){
  const elapsed = now - moveStart;
  const p = clamp(elapsed / moveDuration, 0, 1);
  const yBall = PLATE_Y - R + 18;
  const startX = HOME.x;
  const endX   = RIGHT_PLATE.x - 18;
  let x = startX + playerFlinchOffset, y = HOME.y, rot = 0, sx = 1, sy = 1;
  if (p < 0.32) {
    const t = p/0.32;
    const sx = lerp(1.00, 0.96, t);
    const sy = lerp(1.00, 1.06, t);
    drawShadow(x, 14 + 22*t, 8 - 1.2*t, 0.16);
    drawBallPig(x, yBall, { sx, sy });
  } else if (p < 0.68) {
    const t = easeInOut((p-0.32)/0.36);
    const cx = lerp(startX, endX, t) + playerFlinchOffset;
    const arcLen = (endX - startX) * t;
    theta = arcLen / R;
    drawShadow(cx, 30, 10, 0.16);
    drawBallPig(cx, yBall, { rot: theta });
  } else if (p < 0.84) {
    const t = (p-0.68)/0.16;
    const k = 0.22 * (1 - easeOut(t));
    drawShadow(endX + playerFlinchOffset, 34, 9, 0.18);
    drawBallPig(endX + playerFlinchOffset, yBall, { sx:1+k, sy:1-k });
  } else {
    const t = easeInOut((p-0.84)/0.16);
    const cx = lerp(endX, startX, t) + playerFlinchOffset;
    drawShadow(cx, 30, 10, 0.16);
    ctx.save();
    ctx.globalAlpha = 1 - t; drawBallPig(cx, yBall);
    ctx.globalAlpha = t;     drawPigAt(cx, lerp(yBall, HOME.y, t));
    ctx.globalAlpha = 1; ctx.restore();
  }
}

// ---------------- FART ATTACK (was breath) ----------------
const playerBreathParticles = [];
const opponentBreathParticles = [];
const impactPuffs     = [];

// Emit fart puffs from the butt (behind the pig)
function emitBreath(x, y, dir, isOpponent = false) {
  for (let i = 0; i < 3; i++) {
    // Offset for butt: behind the pig (left for player, right for opponent)
    let offsetX = dir > 0 ? -SIZE * 0.32 : SIZE * 0.32;
    let offsetY = 18; // slightly below center
    const particle = {
      x: x + offsetX + Math.random() * 6,
      y: y + offsetY + Math.random() * 8,
      vx: dir * (320 + Math.random() * 160),
      vy: -30 + Math.random() * 60,
      life: 0,
      ttl: 1400 + Math.random() * 500,
      r: 5 + Math.random() * 6
    };
    if (isOpponent) opponentBreathParticles.push(particle);
    else playerBreathParticles.push(particle);
  }
}

function drawBreath(dt, isOpponent = false) {
  const arr = isOpponent ? opponentBreathParticles : playerBreathParticles;
  for (let i = arr.length - 1; i >= 0; i--) {
    const p = arr[i];
    p.life += dt;
    p.x += p.vx * (dt / 1000);
    p.y += p.vy * (dt / 1000);
    p.vy += 5 * (dt / 1000);
    const a = clamp(1 - p.life / p.ttl, 0, 1);
    ctx.save();
    ctx.globalAlpha = 0.65 * a;
    ctx.fillStyle = "#8aff70"; // green main
    ctx.beginPath(); ctx.arc(p.x, p.y, p.r, 0, Math.PI * 2); ctx.fill();
    ctx.globalAlpha = 0.35 * a;
    ctx.fillStyle = "#5fdc3b"; // green highlight
    ctx.beginPath(); ctx.arc(p.x + 2, p.y + 1, p.r * 0.7, 0, Math.PI * 2); ctx.fill();
    ctx.restore();
    // reach enemy plate -> impact puff
    if (!isOpponent && p.x >= RIGHT_PLATE.x - 12 && p.life < p.ttl) {
      impactPuffs.push({ x: RIGHT_PLATE.x, y: RIGHT_PLATE.y - 20, life: 0, ttl: 320 });
      p.life = p.ttl;
    }
    if (isOpponent && p.x <= LEFT_PLATE.x + 12 && p.life < p.ttl) {
      impactPuffs.push({ x: LEFT_PLATE.x, y: LEFT_PLATE.y - 20, life: 0, ttl: 320 });
      p.life = p.ttl;
    }
    if (p.life >= p.ttl) arr.splice(i, 1);
  }

  // impact visuals
  for (let i=impactPuffs.length-1;i>=0;i--){
    const q = impactPuffs[i];
    q.life += dt;
    const a = clamp(1 - q.life/q.ttl, 0, 1);
    const r = 12 + 16*(q.life/q.ttl);
    ctx.save();
    ctx.globalAlpha = 0.5*a;
    ctx.fillStyle = "#e6f3ff";
    ctx.beginPath(); ctx.arc(q.x, q.y, r, 0, Math.PI*2); ctx.fill();
    ctx.restore();
    if (q.life >= q.ttl) impactPuffs.splice(i,1);
  }
}
function drawPigBreath(now) {
  // Player turns to face away (left)
  ctx.save();
  ctx.scale(-1, 1);
  const elapsed = now - moveStart;
  const p = clamp(elapsed / moveDuration, 0, 1);
  let sy = 1, rot = 0;
  if (p < 0.22) { const t = p / 0.22; sy = 1 + 0.12 * t; rot = -0.04 * t; }
  else if (p < 0.88) { sy = 1.12; rot = -0.04; if (Math.random() < 0.9) emitBreath(HOME.x, HOME.y - 8, +1, false); }
  else { const t = (p - 0.88) / 0.12; sy = 1.12 - 0.12 * t; rot = -0.04 * (1 - t); }
  let x = -HOME.x - playerFlinchOffset;
  drawPigAt(x, HOME.y - 8, { rot, sx: 1, sy });
  drawShadow(x, 34, 10, 0.14);
  drawBreath(1000 / 60, false);
  ctx.restore();
}
function drawOpponentBreath(now) {
  // Opponent turns to face away (right)
  ctx.save();
  ctx.scale(1, 1);
  const elapsed = now - moveStart;
  const p = clamp(elapsed / moveDuration, 0, 1);
  let sy = 1, rot = 0;
  if (p < 0.22) { const t = p / 0.22; sy = 1 + 0.12 * t; rot = -0.04 * t; }
  else if (p < 0.88) { sy = 1.12; rot = -0.04; if (Math.random() < 0.9) emitBreath(ENEMY_CENTER.x, ENEMY_CENTER.y - 8, -1, true); }
  else { const t = (p - 0.88) / 0.12; sy = 1.12 - 0.12 * t; rot = -0.04 * (1 - t); }
  let x = ENEMY_CENTER.x - opponentFlinchOffset;
  drawPigAt(x, ENEMY_CENTER.y - 8, { rot, sx: 1, sy });
  drawShadow(x, 34, 10, 0.14);
  drawBreath(1000 / 60, true);
  ctx.restore();
}

// Simple motion streaks during the run
function drawSpeedLines(x, y, dir = +1) {
  ctx.save();
  ctx.globalAlpha = 0.25;
  ctx.fillStyle = "#9ca3af";
  // three short lines trailing behind the pig
  for (let i = 0; i < 3; i++) {
    const ox = -dir * (18 + i * 16);
    const oy = -10 + i * 8;
    ctx.fillRect(x + ox, y + oy, 26, 3);
  }
  ctx.restore();
}

// ---------------- BODY SLAM (unchanged) ----------------
// BODY SLAM: ground run -> impact -> return
function drawBodySlam(now){
  const elapsed = now - moveStart;
  const p = clamp(elapsed / moveDuration, 0, 1);

  const startX  = HOME.x,  startY  = HOME.y;        // left plate
  // Make impact closer to enemy center for better visual hit
  const impactX = ENEMY_CENTER.x - 8;

  let x = startX, y = startY, rot = 0, sx = 1, sy = 1;

  // Wind-up: 0..0.18, dash: 0.18..0.68, impact: 0.68..0.88, return: 0.88..1
  if (p < 0.18) {
    const t = p / 0.18;
    rot = lerp(0, -0.18, t);
    sy  = lerp(1, 1.12, t);
    drawShadow(x, 36, 11, 0.16);
    drawPigAt(x, y, { rot, sx, sy });
  } else if (p < 0.68) {
    const t = (p - 0.18) / 0.50;
    x = lerp(startX, impactX, easeInOut(t));
    const s = Math.sin((now - moveStart) / 1000 * 16);
    y = startY - 3 * Math.max(0, s);
    rot = -0.18;
    sy  = 1 + 0.04 * Math.sin((now - moveStart) / 1000 * 32);
    drawShadow(x, 34, 10, 0.14);
    drawSpeedLines(x, startY, +1);
    drawPigAt(x, y, { rot, sx, sy });
  } else if (p < 0.88) {
    const t = (p - 0.68) / 0.20;
    x = impactX; y = startY;
    const k = 0.26 * (1 - easeOut(t));
    sx = 1 + k; sy = 1 - k; rot = 0;
    drawShadow(x, 38, 9, 0.20);
    const ringA = 0.5 * (1 - t);
    const ringR = 10 + 22 * t;
    ctx.save();
    ctx.globalAlpha = ringA;
    ctx.strokeStyle = "#e5e7eb";
    ctx.lineWidth = 3;
    ctx.beginPath(); ctx.arc(x + 18, PLATE_Y - 22, ringR, 0, Math.PI*2); ctx.stroke();
    ctx.restore();
    drawPigAt(x, y, { rot, sx, sy });
  } else {
    const t = easeInOut((p - 0.88) / 0.12);
    x = lerp(impactX, startX, t);
    y = startY - 2 * Math.max(0, Math.sin((now - moveStart) / 1000 * 14));
    rot = 0.08 * (1 - t);
    drawShadow(x, 34, 10, 0.14);
    drawSpeedLines(x, startY, -1);
    drawPigAt(x, y, { rot, sx:1, sy:1 });
  }
}


// ---- Opponent Animations (mirrored) ----
function drawOpponentIdle(t){
  ctx.save();
  ctx.scale(-1, 1);
  const squish = 1 + Math.sin(t*2)*0.02;
  let x = -ENEMY_CENTER.x + opponentFlinchOffset;
  drawPigAt(x, ENEMY_CENTER.y, { sy:squish });
  drawShadow(x, 34, 10, 0.14);
  ctx.restore();
}

function drawOpponentDance(t, progress){
  ctx.save();
  ctx.scale(-1, 1);
  const sway = Math.sin(t*4) * 0.22;
  const bounce = Math.max(0, Math.sin(t*8)) * 8;
  const scaleY = 1 + Math.sin(t*8) * 0.06;
  const edge = 0.3;
  let pulse = 1.0;
  if (progress < edge) pulse = 0.9 + 0.1*Math.sin((progress/edge)*Math.PI/2);
  else if (progress > 1-edge) pulse = 0.9 + 0.1*Math.sin(((1-progress)/edge)*Math.PI/2);
  const cx = -ENEMY_CENTER.x + opponentFlinchOffset, cy = ENEMY_CENTER.y - bounce - 4;
  drawPigAt(cx, cy, { rot: sway, sx:pulse, sy: scaleY*pulse });
  drawShadow(cx, 34 + Math.sin(t*8)*3, 10 - Math.sin(t*8)*1.2, 0.16);
  ctx.restore();
}

function drawOpponentBellyRow(now){
  ctx.save();
  ctx.scale(-1, 1);
  const elapsed = now - moveStart;
  const p = clamp(elapsed / moveDuration, 0, 1);
  const yBall = PLATE_Y - R + 18;
  const startX = ENEMY_CENTER.x;
  const endX   = LEFT_PLATE.x - 18;
  let x = startX - opponentFlinchOffset, y = ENEMY_CENTER.y, rot = 0, sx = 1, sy = 1;
  if (p < 0.32) {
    const t = p/0.32;
    const sx = lerp(1.00, 0.96, t);
    const sy = lerp(1.00, 1.06, t);
    drawShadow(-x, 14 + 22*t, 8 - 1.2*t, 0.16);
    drawBallPig(-x, yBall, { sx, sy });
  } else if (p < 0.68) {
    const t = easeInOut((p-0.32)/0.36);
    const cx = lerp(startX, endX, t) - opponentFlinchOffset;
    const arcLen = (endX - startX) * t;
    theta = arcLen / R;
    drawShadow(-cx, 30, 10, 0.16);
    drawBallPig(-cx, yBall, { rot: theta });
  } else if (p < 0.84) {
    const t = (p-0.68)/0.16;
    const k = 0.22 * (1 - easeOut(t));
    drawShadow(-endX + opponentFlinchOffset, 34, 9, 0.18);
    drawBallPig(-endX + opponentFlinchOffset, yBall, { sx:1+k, sy:1-k });
  } else {
    const t = easeInOut((p-0.84)/0.16);
    const cx = lerp(endX, startX, t) - opponentFlinchOffset;
    drawShadow(-cx, 30, 10, 0.16);
    ctx.save();
    ctx.globalAlpha = 1 - t; drawBallPig(-cx, yBall);
    ctx.globalAlpha = t;     drawPigAt(-cx, lerp(yBall, ENEMY_CENTER.y, t));
    ctx.globalAlpha = 1; ctx.restore();
  }
  ctx.restore();
}

function drawOpponentBreath(now){
  ctx.save();
  ctx.scale(-1, 1);
  const elapsed = now - moveStart;
  const p = clamp(elapsed / moveDuration, 0, 1);
  let sy=1, rot=0;
  if (p < 0.22){ const t=p/0.22; sy=1+0.12*t; rot=-0.04*t; }
  else if (p < 0.88){ sy=1.12; rot=-0.04; if (Math.random()<0.9) emitBreath(ENEMY_CENTER.x, ENEMY_CENTER.y-8, -1, true); }
  else { const t=(p-0.88)/0.12; sy=1.12-0.12*t; rot=-0.04*(1-t); }
  let x = -ENEMY_CENTER.x + opponentFlinchOffset;
  drawPigAt(x, ENEMY_CENTER.y - 8, { rot, sx:1, sy });
  drawShadow(x, 34, 10, 0.14);
  drawBreath(1000/60, true);
  ctx.restore();
}

function drawOpponentSlam(now){
  ctx.save();
  ctx.scale(-1, 1);
  const elapsed = now - moveStart;
  const p = clamp(elapsed / moveDuration, 0, 1);
  const startX  = ENEMY_CENTER.x,  startY  = ENEMY_CENTER.y;
  const impactX = LEFT_PLATE.x - 8;
  let x = startX - opponentFlinchOffset, y = startY, rot = 0, sx = 1, sy = 1;
  if (p < 0.18) {
    const t = p / 0.18;
    rot = lerp(0, -0.18, t);
    sy  = lerp(1, 1.12, t);
    drawShadow(-x, 36, 11, 0.16);
    drawPigAt(-x, y, { rot, sx, sy });
  } else if (p < 0.68) {
    const t = (p - 0.18) / 0.50;
    x = lerp(startX, impactX, easeInOut(t)) - opponentFlinchOffset;
    const s = Math.sin((now - moveStart) / 1000 * 16);
    y = startY - 3 * Math.max(0, s);
    rot = -0.18;
    sy  = 1 + 0.04 * Math.sin((now - moveStart) / 1000 * 32);
    drawShadow(-x, 34, 10, 0.14);
    drawSpeedLines(-x, startY, -1);
    drawPigAt(-x, y, { rot, sx, sy });
  } else if (p < 0.88) {
    const t = (p - 0.68) / 0.20;
    x = impactX - opponentFlinchOffset; y = startY;
    const k = 0.26 * (1 - easeOut(t));
    sx = 1 + k; sy = 1 - k; rot = 0;
    drawShadow(-x, 38, 9, 0.20);
    const ringA = 0.5 * (1 - t);
    const ringR = 10 + 22 * t;
    ctx.save();
    ctx.globalAlpha = ringA;
    ctx.strokeStyle = "#e5e7eb";
    ctx.lineWidth = 3;
    ctx.beginPath(); ctx.arc(-x + 18, PLATE_Y - 22, ringR, 0, Math.PI*2); ctx.stroke();
    ctx.restore();
    drawPigAt(-x, y, { rot, sx, sy });
  } else {
    const t = easeInOut((p - 0.88) / 0.12);
    x = lerp(impactX, startX, t) - opponentFlinchOffset;
    y = startY - 2 * Math.max(0, Math.sin((now - moveStart) / 1000 * 14));
    rot = 0.08 * (1 - t);
    drawShadow(-x, 34, 10, 0.14);
    drawSpeedLines(-x, startY, +1);
    drawPigAt(-x, y, { rot, sx:1, sy:1 });
  }
  ctx.restore();
}

  // ---------------- OPPONENT ANGEL DIVE ----------------
  function drawOpponentAngelDive(now) {
    ctx.save();
    ctx.scale(-1, 1);
    const elapsed = now - moveStart;
    const p = clamp(elapsed / moveDuration, 0, 1);
    // Leap up in an arc, then down to player
    const startX = ENEMY_CENTER.x, startY = ENEMY_CENTER.y;
    const endX = LEFT_PLATE.x - 24, endY = LEFT_PLATE.y - 30;
    const t = easeInOut(p);
    const x = -lerp(startX, endX, t) + opponentFlinchOffset;
    const y = lerp(startY, endY, t) - 100 * Math.sin(Math.PI * t);
    const rot = lerp(0, 0.7, t);
    // Angel halo
    if (p < 0.8) {
      ctx.save();
      ctx.globalAlpha = 0.7;
      ctx.beginPath();
      ctx.ellipse(x, y-54, 32, 8, 0, 0, Math.PI*2);
      ctx.strokeStyle = '#ffe066';
      ctx.lineWidth = 4;
      ctx.shadowColor = '#fffbe6';
      ctx.shadowBlur = 12;
      ctx.stroke();
      ctx.restore();
    }
    drawPigAt(x, y, { rot, sx:1, sy:1 });
    drawShadow(x, 34, 10, 0.14);
    ctx.restore();
  }

  // ---------------- OPPONENT WELL DONE COLOR CHANGE ----------------
  function drawOpponentWellDone(now) {
    ctx.save();
    ctx.scale(-1, 1);
    const elapsed = now - moveStart;
    const p = clamp(elapsed / moveDuration, 0, 1);
    ctx.save();
    ctx.filter = `brightness(1.1) sepia(1) hue-rotate(-20deg) saturate(2)`;
    drawPigAt(-ENEMY_CENTER.x + opponentFlinchOffset, ENEMY_CENTER.y, { sx:1, sy:1 });
    ctx.restore();
    drawShadow(-ENEMY_CENTER.x + opponentFlinchOffset, 34, 10, 0.14);
    // Sizzle effect
    if (p > 0.2 && p < 0.9) {
      ctx.save();
      ctx.globalAlpha = 0.18 + 0.12*Math.sin(now/80);
      ctx.beginPath();
      ctx.ellipse(-ENEMY_CENTER.x + opponentFlinchOffset, ENEMY_CENTER.y-60, 38, 14, 0, 0, Math.PI*2);
      ctx.fillStyle = '#fbbf24';
      ctx.fill();
      ctx.restore();
    }
    ctx.restore();
  }

  // ---------------- OPPONENT SELF-HEAL ----------------
  function drawOpponentHeal(now) {
    ctx.save();
    ctx.scale(-1, 1);
    const elapsed = now - moveStart;
    const p = clamp(elapsed / moveDuration, 0, 1);
    ctx.save();
    ctx.shadowColor = '#a7f3d0';
    ctx.shadowBlur = 32 + 32*Math.sin(now/120);
    drawPigAt(-ENEMY_CENTER.x + opponentFlinchOffset, ENEMY_CENTER.y, { sx:1, sy:1 });
    ctx.restore();
    drawShadow(-ENEMY_CENTER.x + opponentFlinchOffset, 34, 10, 0.14);
    // Sparkles
    for (let i=0; i<8; i++) {
      const angle = (i/8)*Math.PI*2 + now/400;
      const r = 38 + 12*Math.sin(now/200 + i);
      const x = -ENEMY_CENTER.x + opponentFlinchOffset + Math.cos(angle)*r;
      const y = ENEMY_CENTER.y - 18 + Math.sin(angle)*r;
      ctx.save();
      ctx.globalAlpha = 0.5 + 0.5*Math.sin(now/100 + i);
      ctx.beginPath();
      ctx.arc(x, y, 4 + 2*Math.sin(now/90 + i), 0, Math.PI*2);
      ctx.fillStyle = '#6ee7b7';
      ctx.fill();
      ctx.restore();
    }
    ctx.restore();
  }

  // ---------------- OPPONENT RAMPAGING CHARGE ----------------
  function drawOpponentCharge(now) {
    ctx.save();
    ctx.scale(-1, 1);
    const elapsed = now - moveStart;
    const p = clamp(elapsed / moveDuration, 0, 1);
    const cycles = 3;
    const t = p * (cycles + 1);
    let phase = Math.floor(t);
    let frac = t - phase;
    let dir = (phase % 2 === 0) ? 1 : -1;
    let startX = dir === 1 ? ENEMY_CENTER.x : LEFT_PLATE.x - 24;
    let endX = dir === 1 ? LEFT_PLATE.x - 24 : ENEMY_CENTER.x;
    let x = -lerp(startX, endX, easeInOut(frac)) + opponentFlinchOffset;
    let y = ENEMY_CENTER.y - 10 + 8*Math.sin(now/60 + phase*2);
    let rot = dir * 0.18 * Math.sin(Math.PI * frac);
    if (Math.random() < 0.5) {
      ctx.save();
      ctx.globalAlpha = 0.18;
      ctx.beginPath();
      ctx.ellipse(x, y+SIZE/2+18, 32+16*Math.random(), 8+4*Math.random(), 0, 0, Math.PI*2);
      ctx.fillStyle = '#fbbf24';
      ctx.fill();
      ctx.restore();
    }
    drawPigAt(x, y, { rot, sx:1.08, sy:0.96 });
    drawShadow(x, 38, 11, 0.18);
    ctx.restore();
  }
// ---- Opponent logic ----
function playOpponentMove(move) {
  mode = "animating";
  currentMove = "opponent-" + move;
  moveStart = performance.now();
  moveDuration = {
    dance: 1200,
    belly: 1400,
    breath: 1600,
    slam: 1300,
    angel: 1300,
    welldone: 1000,
    heal: 1200,
    charge: 1500
  }[move];
  setStatus({
    dance : "Opponent used Piggy Dance!",
    belly : "Opponent used Belly Row!",
    breath: "Opponent used Fart Attack!",
    slam  : "Opponent used Body Slam!",
    angel : "Opponent used Angel Dive!",
    welldone : "Opponent is Well Done!",
    heal : "Opponent healed itself!",
    charge : "Opponent rampaged wildly!"
  }[move]);
  theta = 0;
  // Only clear the correct breath/impact arrays for the opponent
  opponentBreathParticles.length = 0;
  impactPuffs.length = 0;
}

// ---------------- ANGEL DIVE ----------------
function drawAngelDive(now) {
  const elapsed = now - moveStart;
  const p = clamp(elapsed / moveDuration, 0, 1);
  // Leap up in an arc, then down to enemy
  const startX = HOME.x, startY = HOME.y;
  const endX = RIGHT_PLATE.x - 24, endY = RIGHT_PLATE.y - 30;
  const t = easeInOut(p);
  const x = lerp(startX, endX, t) + playerFlinchOffset;
  const y = lerp(startY, endY, t) - 100 * Math.sin(Math.PI * t);
  const rot = lerp(0, 0.7, t);
  // Angel halo
  if (p < 0.8) {
    ctx.save();
    ctx.globalAlpha = 0.7;
    ctx.beginPath();
    ctx.ellipse(x, y-54, 32, 8, 0, 0, Math.PI*2);
    ctx.strokeStyle = '#ffe066';
    ctx.lineWidth = 4;
    ctx.shadowColor = '#fffbe6';
    ctx.shadowBlur = 12;
    ctx.stroke();
    ctx.restore();
  }
  drawPigAt(x, y, { rot, sx:1, sy:1 });
  drawShadow(x, 34, 10, 0.14);
}

// ---------------- WELL DONE COLOR CHANGE ----------------
function drawWellDone(now) {
  const elapsed = now - moveStart;
  const p = clamp(elapsed / moveDuration, 0, 1);
  ctx.save();
  ctx.filter = `brightness(1.1) sepia(1) hue-rotate(-20deg) saturate(2)`;
  drawPigAt(HOME.x + playerFlinchOffset, HOME.y, { sx:1, sy:1 });
  ctx.restore();
  drawShadow(HOME.x + playerFlinchOffset, 34, 10, 0.14);
  // Sizzle effect
  if (p > 0.2 && p < 0.9) {
    ctx.save();
    ctx.globalAlpha = 0.18 + 0.12*Math.sin(now/80);
    ctx.beginPath();
    ctx.ellipse(HOME.x + playerFlinchOffset, HOME.y-60, 38, 14, 0, 0, Math.PI*2);
    ctx.fillStyle = '#fbbf24';
    ctx.fill();
    ctx.restore();
  }
}

// ---------------- SELF-HEAL ----------------
function drawHeal(now) {
  const elapsed = now - moveStart;
  const p = clamp(elapsed / moveDuration, 0, 1);
  ctx.save();
  ctx.shadowColor = '#a7f3d0';
  ctx.shadowBlur = 32 + 32*Math.sin(now/120);
  drawPigAt(HOME.x + playerFlinchOffset, HOME.y, { sx:1, sy:1 });
  ctx.restore();
  drawShadow(HOME.x + playerFlinchOffset, 34, 10, 0.14);
  // Sparkles
  for (let i=0; i<8; i++) {
    const angle = (i/8)*Math.PI*2 + now/400;
    const r = 38 + 12*Math.sin(now/200 + i);
    const x = HOME.x + playerFlinchOffset + Math.cos(angle)*r;
    const y = HOME.y - 18 + Math.sin(angle)*r;
    ctx.save();
    ctx.globalAlpha = 0.5 + 0.5*Math.sin(now/100 + i);
    ctx.beginPath();
    ctx.arc(x, y, 4 + 2*Math.sin(now/90 + i), 0, Math.PI*2);
    ctx.fillStyle = '#6ee7b7';
    ctx.fill();
    ctx.restore();
  }
}

// ---------------- RAMPAGING CHARGE ----------------
function drawCharge(now) {
  const elapsed = now - moveStart;
  const p = clamp(elapsed / moveDuration, 0, 1);
  const cycles = 3;
  const t = p * (cycles + 1);
  let phase = Math.floor(t);
  let frac = t - phase;
  let dir = (phase % 2 === 0) ? 1 : -1;
  let startX = dir === 1 ? HOME.x : RIGHT_PLATE.x - 24;
  let endX = dir === 1 ? RIGHT_PLATE.x - 24 : HOME.x;
  let x = lerp(startX, endX, easeInOut(frac)) + playerFlinchOffset;
  let y = HOME.y - 10 + 8*Math.sin(now/60 + phase*2);
  let rot = dir * 0.18 * Math.sin(Math.PI * frac);
  if (Math.random() < 0.5) {
    ctx.save();
    ctx.globalAlpha = 0.18;
    ctx.beginPath();
    ctx.ellipse(x, y+SIZE/2+18, 32+16*Math.random(), 8+4*Math.random(), 0, 0, Math.PI*2);
    ctx.fillStyle = '#fbbf24';
    ctx.fill();
    ctx.restore();
  }
  drawPigAt(x, y, { rot, sx:1.08, sy:0.96 });
  drawShadow(x, 38, 11, 0.18);
}

// ---- Main loop ----
let t0 = performance.now();
function loop(now){
  // Update flinch states
  // Oscillating flinch for more dramatic effect
  if (playerFlinch > 0) {
    playerFlinch--;
    // Oscillate left/right with decaying amplitude
    const flinchT = playerFlinch / 16;
    playerFlinchOffset = Math.sin(flinchT * Math.PI * 6) * (36 * flinchT);  
  } else {
    playerFlinchOffset = 0;
  }
  if (opponentFlinch > 0) {
    opponentFlinch--;
    const flinchT = opponentFlinch / 16;
    opponentFlinchOffset = Math.sin(flinchT * Math.PI * 6) * (36 * flinchT);
  } else {
    opponentFlinchOffset = 0;
  }

  const t = (now - t0)/1000;
  drawPlates();

  // Always draw both breath clouds so they persist and animate
  drawBreath(1000/60, false); // player
  drawBreath(1000/60, true);  // opponent

  if (mode === "animating") {
    const elapsed = now - moveStart;
    const progress = Math.min(1, elapsed / moveDuration);
    // Player move
    if (currentMove === "dance") {
      drawPigDance(t, progress);
      drawOpponentIdle(t);
      if (elapsed >= moveDuration) endMove("Pig finished dancing!");
    } else if (currentMove === "belly") {
      drawBellyRow(now);
      drawOpponentIdle(t);
      if (elapsed >= moveDuration) endMove("It rolled back!");
    } else if (currentMove === "breath") {
      drawPigBreath(now);
      drawOpponentIdle(t);
      if (elapsed >= moveDuration) endMove("A stinky fart hits the foe!");
    } else if (currentMove === "slam") {
      drawBodySlam(now);
      drawOpponentIdle(t);
      if (elapsed >= moveDuration) endMove("Slam complete!");
    } else if (currentMove === "angel") {
      drawAngelDive(now);
      drawOpponentIdle(t);
      if (elapsed >= moveDuration) endMove("Pig performed an angel dive!");
    } else if (currentMove === "welldone") {
      drawWellDone(now);
      drawOpponentIdle(t);
      if (elapsed >= moveDuration) endMove("Pig is well done!");
    } else if (currentMove === "heal") {
      drawHeal(now);
      drawOpponentIdle(t);
      if (elapsed >= moveDuration) endMove("Pig healed itself!");
    } else if (currentMove === "charge") {
      drawCharge(now);
      drawOpponentIdle(t);
      if (elapsed >= moveDuration) endMove("Pig rampaged wildly!");
    // Opponent move (mirrored)
    } else if (currentMove === "opponent-dance") {
      drawPigIdle(t);
      drawOpponentDance(t, progress);
      if (elapsed >= moveDuration) endMove("Opponent finished dancing!");
    } else if (currentMove === "opponent-belly") {
      drawPigIdle(t);
      drawOpponentBellyRow(now);
      if (elapsed >= moveDuration) endMove("Opponent rolled back!");
    } else if (currentMove === "opponent-breath") {
      drawPigIdle(t);
      drawOpponentBreath(now);
      if (elapsed >= moveDuration) endMove("A stinky fart hits you!");
    } else if (currentMove === "opponent-slam") {
      drawPigIdle(t);
      drawOpponentSlam(now);
      if (elapsed >= moveDuration) endMove("Opponent slammed!");
    } else if (currentMove === "opponent-angel") {
      drawPigIdle(t);
      drawOpponentAngelDive(now);
      if (elapsed >= moveDuration) endMove("Opponent performed an angel dive!");
    } else if (currentMove === "opponent-welldone") {
      drawPigIdle(t);
      drawOpponentWellDone(now);
      if (elapsed >= moveDuration) endMove("Opponent is well done!");
    } else if (currentMove === "opponent-heal") {
      drawPigIdle(t);
      drawOpponentHeal(now);
      if (elapsed >= moveDuration) endMove("Opponent healed itself!");
    } else if (currentMove === "opponent-charge") {
      drawPigIdle(t);
      drawOpponentCharge(now);
      if (elapsed >= moveDuration) endMove("Opponent rampaged wildly!");
    }
  } else {
    drawPigIdle(t);
    drawOpponentIdle(t);
  }
  requestAnimationFrame(loop);
}

function endMove(msg) {
  // Flinch for all attacks except heal and well done (and dance)
  const playerFlinchMoves = [
    "opponent-breath", "opponent-belly", "opponent-slam", "opponent-angel", "opponent-charge"
  ];
  const opponentFlinchMoves = [
    "breath", "belly", "slam", "angel", "charge"
  ];
  if (playerFlinchMoves.includes(currentMove)) {
    playerFlinch = 16;
  } else if (opponentFlinchMoves.includes(currentMove)) {
    opponentFlinch = 16;
  }

  if (currentMove && currentMove.startsWith("opponent-")) {
    // End of opponent's move, return to player
    mode = "idle";
    currentMove = null;
    setMovesEnabled(true);
    setStatus("Your turn! Choose a move…");
  } else {
    // End of player's move, trigger opponent
    mode = "idle";
    currentMove = null;
    setMovesEnabled(false);
    setStatus("Opponent is thinking…");
    setTimeout(() => {
      const moves = ["dance", "belly", "breath", "slam", "angel", "welldone", "heal", "charge"];
      const move = moves[Math.floor(Math.random() * moves.length)];
      playOpponentMove(move);
    }, 700);
  }
}

// ---- Buttons ----
btnDance .addEventListener('click', () => playMove("dance", 1200));
btnBelly .addEventListener('click', () => playMove("belly", 1400));
btnBreath.addEventListener('click', () => playMove("breath", 1600));
btnSlam  .addEventListener('click', () => playMove("slam",  1300));
btnAngel   .addEventListener('click', () => playMove("angel", 1300));
btnWellDone.addEventListener('click', () => playMove("welldone", 1000));
btnHeal    .addEventListener('click', () => playMove("heal", 1200));
btnCharge  .addEventListener('click', () => playMove("charge", 1500));

// Start when image is ready
pig.onload = () => requestAnimationFrame(loop);
</script>
</body>
</html>